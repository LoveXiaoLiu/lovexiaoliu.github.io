<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>架构 on Gra55&#39;s Blog</title>
    <link>/categories/%E6%9E%B6%E6%9E%84/</link>
    <description>Recent content in 架构 on Gra55&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 30 Dec 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/categories/%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计模式概述</title>
      <link>/blog/2019/architecture/design-patterns-overview/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/architecture/design-patterns-overview/</guid>
      <description>为什么需要设计模式？
套用树人哥的一句话：其实世上本没有设计模式，走的人多了就有了设计模式。
本来大家都是按照自己的方式写代码，然后根据不同需求，写出各种可扩展的、可维护的代码。然后，1995 年，GoF 四个人就将这些经验性代码总结出来，汇总成 23 种编程范式。
其实就是编程的最佳实践，针对这种问题你就得这么干，因为根据历史经验来看，这么干是最优的。
设计模式的本质是面向对象设计原则的实际应用。
 0x00 设计模式分类 按目的来分  创建型：用于描述如何创建对象，将对象的创建与使用分离开 结构型：用于描述如何将类或对象按照某种布局组成更大的结构（类似于聚合） 行为型：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务（类似于组合）  按作用范围来分  类模式：用于描述类与子类的关系，是静态的，在编译时就能确定下来（通过继承实现） 对象模式：用于描述对象之间的关系，在运行时刻是变化的（通过聚合/组合实现）     范围\目的 创建型 结构型 行为型     类模式 工厂方法 适配器（类） 模板方法、解释器   对象模式 单例、原型、抽象工厂、建造者 代理、适配器（对象）、桥接、装饰、外观、享元、组合 策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录    0x01 Prin 1：开闭原则 Software entities should be open for extension, but closed for modification.
 需求变更的时候，尽量通过扩展来实现需求，而不是通过修改源码来实现。 开闭原则是面向对象程序设计的终极目标 实现方法：通过抽象约束、封装变化来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在具体实现类中。  0x02 Prin 2：里氏替换原则 Inheritance should ensure that any property proved about supertype objects also holds for subtype objects.</description>
    </item>
    
    <item>
      <title>设计模式：工厂方法</title>
      <link>/blog/2019/architecture/design-patterns-factory-method/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/architecture/design-patterns-factory-method/</guid>
      <description>0x00 模式概述 工厂方法模式定义：定义一个创建产品对象的工厂接口，将产品对象的创建工作推迟到具体子工厂类中。
如果创建的产品对象不多，那么只需要一个工厂类就可以完成。这个叫做简单工厂。简单工厂不属于 GoF 23 种设计模式，因为在增加新产品时会违反开闭原则。
工厂方法是简单工厂的的进一步抽象，使增加新产品时不需要修改原来的代码，满足开闭原则。
0x01 场景  客户只知道创建产品的工厂名，不知道具体的产品名 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口  0x02 解决方案 工厂方法其实是依赖倒置原则的体现，在简单工厂中，Client 创建类 A 的实例，也就是依赖于 A，这样的耦合性很高，增加一个产品 B，在 Client 中就需要进行条件判断才知道需要创建哪个类的实例。
所以使用依赖倒置
0x03 优缺点 优点：  用户只需要知道具体工厂的名字，就可以得到想要的产品对象，不需要知道产品的具体创建过程。 在系统增加新的产品时，只需要添加一个具体产品类和对应的具体工厂类，不需要修改原工厂代码，满足开闭原则。  缺点：  每增加一个产品就需要增加一个具体的产品类和具体工厂类，增加系统复杂性。   参考：
📌 软件设计模式概述</description>
    </item>
    
    <item>
      <title>分布式事务：TCC</title>
      <link>/blog/2019/architecture/distributed-transaction-tcc/</link>
      <pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/architecture/distributed-transaction-tcc/</guid>
      <description>什么是分布式？
 与分布式对立的概念是单体系统，分布式系统是将不同的功能模块拆分成不同的服务，微服务就是一个典型的分布式系统。  分布式事务常见解决方案:
 2PC两段提交协议 3PC三段提交协议(弥补两端提交协议缺点) TCC或者GTS(阿里) 消息中间件最终一致性 使用LCN解决分布式事物，理念“LCN并不生产事务,LCN只是本地事务的搬运工”。   0x00 TCC TCC 是 Try、Confire、Cancel 的缩写。
又称补偿机制，核心思想是：针对每个操作（Try）都要注册一个与其对应的确认（Confirm）和补偿（Cancel）操作。
0x01 5 个步骤 ①、向协调者发起开启事务请求
②、Try 阶段：Try 阶段负责把所有服务的业务资源预留和锁住。类似于 MySQL DML 操作，会加行锁
③、Confirm or Cancel 阶段：如果 Try 阶段涉及的所有服务都确认执行成功，则向协调者发送 Confirm（commit），否则发送 Cancel（rollback）
④、协调者根据业务发送的 Confirm or Cancel，向所有服务发送相应的 Confirm or Cancel 请求
⑤、各服务提交本地事务
+----------------------+ 1 +------------------------+ | +---------------&amp;gt;+ | | APP | | Coordination service | | +---------------&amp;gt;+ | +-+--+--+------+--+--+-+ 3 +------------------------+ | | | | | | 2 | | | | | | 2 +------------------------+ | | | | +--------------------------+ | 4 | | | | 4 | | +------------------------+ | | +--------------------------+ | | | 4&#39; | | 4&#39; | | | | +----------------------+ +-------------------------+ | | | | | | | | v v v v v v +-+--+----+-------------------------+ +---------------------+---+--+-+ | service A | | service B | +----------------------+------------+ +-------+----------------------+ | | 5 | | 5 v v +-----+-------+ +---+---------+ | DB 1 | | DB 2 | +-------------+ +-------------+ 与 2PC 比较： 2PC 是资源层面的分布式事务，强一致，整个操作中资源一直被加锁，不需要开发者参与。</description>
    </item>
    
    <item>
      <title>分布式事务：2PC &amp; 3PC</title>
      <link>/blog/2019/architecture/distributed-transaction-2pc-3pc/</link>
      <pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/architecture/distributed-transaction-2pc-3pc/</guid>
      <description>什么是分布式？
 与分布式对立的概念是单体系统，分布式系统是将不同的功能模块拆分成不同的服务，微服务就是一个典型的分布式系统。  分布式事务常见解决方案:
 2PC两段提交协议 3PC三段提交协议(弥补两端提交协议缺点) TCC或者GTS(阿里) 消息中间件最终一致性 使用LCN解决分布式事物，理念“LCN并不生产事务,LCN只是本地事务的搬运工”。   0x00 CAP 定理 所谓定理就是别人发现的规律，并且已经证实该规律是正确的（就像勾股定理，它永远是正确的，你直接用它的结论就行，你也可以自己证实其正确性）。
CAP 定理定义：在异步网络中（不可靠的网络），不可能同时实现并发读/写状态下的 availability、consistency。即 Consistency、Availability 和 Partition Tolerance 不能同时满足。
这里证明了 CAP 是成立的
0x01 2PC Two-Phase Commit Protocol（两阶段提交协议），注意 ，2PC 是一个协议。
2PC 是一个强一致、中心化的原子提交协议。这里面包含一个中心化的协调者节点（coordinator）。
Example：订单服务 A，需要调用支付服务 B 去支付，支付成功则处理购物订单为待发货状态，否则就需要将购物订单处理为失败状态。
两个阶段： Prepare 阶段
①、事务询问：Coordinator 收到请求以后，向所有参与者发送事务预处理请求，即 Prepare。开始等待参与者响应
②、执行本地事务：各参与者执行本地事务，但是不会真正提交，而是先向 Coordinator 报告自己的情况
③、返回事务询问响应：参与者根据本地事务的情况返回 Yes or No
Commit 阶段
④、Coordinator 统计参与者的返回值，返送 commit（参与者全回复 Yes） 或者 rollback（有参与者回复 No）
⑤、执行本地 commit 或者 rollbak
| | request v +-----------------+-----------------+ | Coordinator | +-+------+----+-------+---+------+--+ | ^ | | ^ | | | | | | | 4 | 3 | | 1 1 | | 3 | 4 | | | | | | v | v v | v +-----+------+----+-+ ++---+------+-------+ | Server A | | Server B | +------+-----+------+ +---+-----+---------+ | | | | 5 | | 2 2 | | 5 | | | | v v v v +--+-----+---+ +-+-----+----+ | DB 1 | | DB 2 | +------------+ +------------+ 优缺点： 优点</description>
    </item>
    
  </channel>
</rss>