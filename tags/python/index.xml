<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on Gra55&#39;s Blog</title>
    <link>/tags/python/</link>
    <description>Recent content in python on Gra55&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 20 Dec 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Python 标准库：re</title>
      <link>/blog/2019/python/python-standard-library-re/</link>
      <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/python/python-standard-library-re/</guid>
      <description>NOTE：
 正则表达式的 pattern 和被匹配的字符串可以是 Unicode 和 8-bit 字符串 正则表示式使用反斜杠（\）来表示特殊的集合，要匹配反斜杠需要使用双反斜杠（\）来表示。Python 中的字符串恰好也使用反斜杠（\）来表示特殊字符或集合，所以要是用 Python 字符串来表示正则表达式中的反斜杠需要使用 4 个反斜杠（\\）。有一个简单的方法，就是使用 Python 的 raw string（字符串前加前缀 r），raw string 内的字符串不进行任何转译。    0x00 正则表达式语法 这个知识点很复杂，需要单独来讨论，先给个参考链接：Regular Expression Syntax
0x01 模块内容  这里主要讲 re 模块内的函数使用
 re.compile(pattern, flags=0)
 将正则表达式的 pattern 编译成 _sre.SRE_Pattern 对象。 通过指定 flag 的值可以改变正则表达式匹配的行为，flag 的值可以通过 | 操作符组合多个值。 re.compile() 返回的对象可以多次使用，不需要使用时再次编译，提高效率。但是，如何一个程序中只使用很少的几个正则表达式，那就不需要担心编译的问题了，因为 re.match()、re.search()、re.compile() 等都会将编译后的对象进行缓存（使用的正则表达式多了就不行了，因为毕竟缓存是有限的）。  re.DEBUG
 显示被编译的表达式的 debug 信息  re.I &amp;amp;&amp;amp; re.IGNORECASE
 re.I 是 re.</description>
    </item>
    
    <item>
      <title>Python 标准库：Queue</title>
      <link>/blog/2019/python/python-standard-library-queue/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/python/python-standard-library-queue/</guid>
      <description>Btw：
Python3 中，Queue 模块已经重命名为 queue。Python3.7 中增加了一个 SimpleQueue 类，其他内容同 Python2。
 0x00 Overview Queue 模块实现的是多生产者、多消费者的队列。因此它是线程安全的，可以在多线程下使用。因为 Queue 类内部实现了所有必须的锁。
Queue 模块提供了三种类型的队列，三种类型的主要差异是获取数据的顺序不同。
0x01 队列 class：Queue(maxsize=0)
 FIFO（先进先出）队列。
 maxsize 用来设置队列的最大容量，一旦到达最大值，插入操作就会被阻塞住，直到队列内的内容被消费。
 如果 maxsize 小于等于 0，队列的容量是无限大。
  class：LifoQueue(maxsize=0)
 LIFO（先进后出）队列，类似于栈。
 其他规则同 Queue。
  class：PriorityQueue(maxsize=0)
 优先队列，内部使用 heapq 实现。
 其他规则同 Queue。
 优先返回优先级低的数据，典型的数据模式是一个元组：(priority_number, data)
  exception：Empty
 在一个空队列调用非阻塞 get() 或者 get_nowait() 时会抛出此异常。  exception：Full
 在一个容量达到最大值的队列调用非阻塞 put() 或者 put_nowait() 时会抛出此异常。  0x02 Queue 对象介绍  LifoQueue，PriorityQueue 都是继承自 Queue</description>
    </item>
    
    <item>
      <title>抛弃 Python2，从此使用 Python3</title>
      <link>/blog/2019/python/why-upgrade-python3/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/python/why-upgrade-python3/</guid>
      <description>为什么要使用 Python3？我 2 用的好好的。（py 版本演进过程；2018 年开发者问卷调查；）
Python 2 3 的特性对比
到底写 2 还是写 3，还是两个都写。（如果是自己的项目，只写 py3，如果是提供的第三方库，需要写 3 代码来兼容 2。为什么不是写 2 的代码兼容 3 呢？2 孔的插座好比 Python2，3 孔的好比 Python3，本来是 2 孔的充电器插 2 孔的电源，3 孔的插 3 孔的。现在假如 2 孔的插座快淘汰了，你是愿意给 3 孔的充电器安装一个 2 孔的转接头，让他可以用使用 2 孔的插座呢，还是另外一种做法）
如何逐步迁移到 Python 3（不迁移的话，你永远在使用 py2，因为你迈不出第一步）（需要注意很多老库不支持 py3）
迁移工具有哪些
如何部署 Python 2 和 Python3 的环境，并且还有虚拟环境
 0x00 为什么要升级到 Python3 Python2 + Python2 算是一种比较古老的语言 + 2010 年 7 月，发布 2.7.0 版本的时候，就宣布了以后不会再发布 Python 2.</description>
    </item>
    
    <item>
      <title>Python 与 Golang 语法特性对比</title>
      <link>/blog/2019/go/go-compare-python/</link>
      <pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/go/go-compare-python/</guid>
      <description>0x00 缘起 之前整体把 golang 的语法过了一遍，花了大概几个小时。
然鹅，2 天没写 go 代码，语法就忘完了，还得回过头去查一次，真是浪费时间。
所以，我就想到了这个联想记忆，通过熟悉的东西，来记住陌生的东西。
0x01 语法特性对比  参考：go 语言之旅
     Python Go     包声明 文件名 文件内定义：package main   引入包 import json import &amp;ldquo;math/rand&amp;rdquo;   模块对象暴露 __all__ 包内对象首字母大写   函数 def 关键字 func 关键字   函数多指返回 return x, y return x, y（特例：func split(sum int) (x, y int) { x = sum * 4 / 9; y = sum - x; return }）   变量 动态类型 关键字 var，在变量名后声明（多个变量类型相同时，前边类型可以忽略）   变量初始化 直接赋值 如果提供初始值，则不需要指明类型   短变量声明 / :=（函数外必须使用 var 关键字）   基本类型 int、string、bool、list、dict、tuple bool、string、int[8, 16, 32, 64]、uint[8, 16, 32, 64]、uintptr、byte（uint8 的别名）、rune（int32 的别名；表示一个 Unicode 码点）、float32、float64、complex64、complex128   零值 / 没有赋初值的变量默认为零值（int 为 0；bool 为 false；字符串为 &amp;ldquo;；指针为 nil；切片为 nil，它的长度和容量为 0，且没有底层数组；映射为 nil，nil 映射既没有键，也不能添加键；）   类型转换 同 go 语言 T(v) 将值 v 转换为类型 T（不同类型直接赋值需要显式转换）   常量 与变量相同 关键字 const，不能使用 := 语法（常量不指明类型的话，会根据上下文自动识别其类型）   for for i in [1, 2, 3]: for i:=0; i&amp;lt;10; i++ {xxx}（初始化语句和后置语句是可选的）   while while True: for sum &amp;lt; 1000 {xxx}   死循环 while True: for {xxx}   if if i &amp;lt; 10: xxx else: xxx if v := math.</description>
    </item>
    
    <item>
      <title>开发 Python 第三方包，上传到 PyPI</title>
      <link>/blog/2019/python/python-package-pypi/</link>
      <pubDate>Tue, 09 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/python/python-package-pypi/</guid>
      <description>0x00 初始化 skeleton 开源一个 Python 第三方包，需要配置很多额外的东西（pip 需要的 setup.cfg，CI/CD 需要的 .travis.yml 等），这些东西完全没必要自己来逐一创建。
所以我们需要一个脚手架来快速创建项目的 skeleton。这里我推荐使用 cookiecutter-X 系列工具。
我这里开发 pypi 包，使用 cookiecutter-pypackage 模板。
cookiecutter https://github.com/audreyr/cookiecutter-pypackage.git  0x01 生态配置 创建完项目 skeleton 以后，需要关联 Travis 账号、ReadTheDocs 账号等。步骤如下：
 将 repo 添加到 GitHub 中 将该 repo 添加到 Travis CI 中（需要注册 Travis 账号） 安装 dev requirement.txt 到虚拟开发环境中：pip install -r requirements_dev.txt 注册项目到 PyPI 中（需要注册 PyPI 账号）  生成 tar&amp;amp;wheel 包：python setup.py sdist bdist_wheel 上传包到 PyPI 中：python -m twine upload dist/*  将该 repo 添加到 ReadTheDocs 中  0x02 迭代开发  更新项目代码，开发新 features 使用 bumpversion 升级版本：bumpversion --current-version 0.</description>
    </item>
    
  </channel>
</rss>