<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2020 on Gra55&#39;s Blog</title>
    <link>/tags/2020/</link>
    <description>Recent content in 2020 on Gra55&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 13 Jan 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/2020/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>基础算法：回溯法</title>
      <link>/blog/2020/algorithm/back-tracking/</link>
      <pubDate>Mon, 13 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/2020/algorithm/back-tracking/</guid>
      <description>0x00 算法概述 回溯算法其实是一种枚举算法（穷举法），是一种暴力解法，时间复杂度比较高。
回溯法通过深度优先遍历的方法来尝试所有可能的解，当发现某一个分支无法满足求解条件，立马退回一步重新选择（回溯），尝试其他路径。如果只求一个解时，搜索到可用解后就停止搜索；如果求问题的所有解，就必须遍历所有解空间。
0x01 解题步骤  针对所给问题，确定解空间：需要确定问题的解空间是否存在一个（最优）解 确定搜索规则 以深度优先策略开始搜索解空间，搜索过程中通过剪枝函数避免无效搜索  什么是剪枝函数？
 剪枝函数是对无效解的过滤策略（明知道这条路径走下去不会得到解或最优解，所以就提前回溯，提高效率） 可行性剪枝：提前判断当前路径无法求出解，就可以提前回溯 最优化剪枝：声明一个变量存储当前最优解，如果可以提前判断当前路径无法满足最优解的条件，就提前回溯 剪枝函数特别难找，好的剪枝函数可以极大的降低算法的时间复杂度  0x02 实现方式  非递归 递归   参考：
📌 五大常用算法之四：回溯法
📌 “通用解题法”之回溯中的“剪枝”</description>
    </item>
    
    <item>
      <title>AVL Tree 概述</title>
      <link>/blog/2020/algorithm/avl-tree/</link>
      <pubDate>Fri, 10 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/2020/algorithm/avl-tree/</guid>
      <description>0x00 前言 最早出现的是二叉树，随后人们发现二叉树可以用来二分查找，所以出现了二叉搜索树。
但是二叉搜索树在极端情况会退化成单链表的形式，所以出现了平衡二叉搜索树，即AVL 树（AVL 取自发明它的两个人的名字首字母，话说老外都爱这个干，以自己名字命名各种算法）
但是AVL 树也是有缺陷的，删除和插入效率很低（因为需要旋转多次），所以出现了红黑树，红黑树不是严格的平衡树，所以查找效率可能会低一点。
本文主要介绍AVL 树，后续出单独的文章介绍红黑树。
0x01 特性  必须是一颗二叉搜索树 每个节点的左子树和右子树的高度差的绝对值不能大于 1 查找、插入、删除的平均和最坏时间复杂度都是 O(logn)  0x02 术语 平衡因子（Balance Factor）
 二叉树节点的左子树高度减去右子树高度的值，称为该节点的平衡因子  最小不平衡子树
 距离插入节点最近的，且平衡因子绝对值大于 1 的节点为根的树，就是最小不平衡子树  0x03 实现 节点结构 下面的节点结构包含了节点的高度，也可以存储平衡因子和父节点。
class TreeNode(object): def __init__(self, value): self.value = value self.left = None self.right = None self.height = 0 AVL 类提供的函数 失衡调整 - 左单旋（在最小不平衡子树的右子树中插入右孩子时）
+---+ +---+ +---+ | 4 | | 4 | | 5 | +---+ +---+ +---+ | | | | +---+ +---+ +---+ +---+ | 5 | | 5 | | 4 | | 6 | +---+ +---+ +---+ +---+ | +---+ | 6 | +---+ def leftRotation(proot): &amp;#34;&amp;#34;&amp;#34;单左旋转操作:param proot: 最小失衡子树的根节点:rtype: TreeNode&amp;#34;&amp;#34;&amp;#34; # 左旋 tmpNode = proot.</description>
    </item>
    
    <item>
      <title>LRU 算法概述</title>
      <link>/blog/2020/algorithm/lru-cache/</link>
      <pubDate>Mon, 06 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/2020/algorithm/lru-cache/</guid>
      <description>0x00 算法概述 LRU（Least-recently-used）：最近最少被使用的某个东西。最早使用在内存中，表示最近最少被使用的内存将会被释放。
0x01 算法实现 如果想要这个算法的 get 和 set 时间复杂度都为 O(1)，我们这里需要使用两种数据结构 dict 和双向链表。
dict 获取元素的时间复杂度是 O(1)，set 元素时通过字典先找到已存在的元素，然后将这个元素挪到链表的尾部，时间复杂度也是 O(1)。结构如下所示：
+----------+ +----------+ +----------+ +----------+ | key-root | | key-A | | key-B | | key-C | +----------+ +----+-----+ +----+-----+ +----+-----+ | | | | | | | | v v v v +----+-----------------+----------------+------------------+----------+ | hash function | +----+-----------------+----------------+------------------+----------+ | | | | v v v v +----+-----+ +----+-----+ +---+------+ +----+-----+ +------&amp;gt;+ +-----&amp;gt;+ +------+ +-----&amp;gt;+ +--------+ | | root | | A | | B | | C | | | +----+ +&amp;lt;-----+ +------+ +&amp;lt;-----+ +&amp;lt;---+ | | | +----------+ +----------+ +----------+ +----------+ | | | | | | | +--------------------------------------------------------------------------+ | +---------------------------------------------------------------------------------+ 0x02 代码实现 在 Python 3 的内置模块 functools 中（Python 2 中没有），给出了 lru_cache 的实现，这应该就是用 Python 来实现 lru cache 的最佳实践了。</description>
    </item>
    
    <item>
      <title>Python 基础知识点</title>
      <link>/blog/2020/python/python-basic-knowledge/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/2020/python/python-basic-knowledge/</guid>
      <description>以下知识点只给出结论，不给予论证，请自行测试。
 0x00 实例属性的访问顺序  __getattribute__ 类的数据描述符属性 实例的属性 类的非数据描述符属性 类的普通属性 __getattr__  0x01 实例属性的赋值顺序  类的数据描述符属性 实例属性  0x02 内存管理  引用计数 内存池 垃圾回收  0x03 垃圾回收  引用计数 标记清除 分代回收  0x04 作用域  global 关键字用来访问全局作用域的变量值。
nonlocal 关键字（只有 Python 3 支持）用来访问 Enclosing locals（闭包）作用域的变量值。
Python 没有块作用域，for 语句范围不是单独的作用域。
  Local Enclosing locals Global Built-in  0x05 is 关键字  is 用来比较变量的地址 == 用来比较变量的值  0x06 单引号/双引号/三引号  单引号和双引号等效，换行需要使用反斜杠（\） 三引号可以直接换行，可以包含任何形式的字符串  0x07 自省  运行时能够查看对象内部的属性或状态 自省函数：type()、isinstance()、dir()、hasattr()、getattr()  0x08 staticmethod &amp;amp; classmethod  staticmethod &amp;amp; classmethod 都是内置类型，属于非数据描述符 可以将类内的方法转变成静态方法和类方法（从 Python 2.</description>
    </item>
    
    <item>
      <title>Python 标准库：abc</title>
      <link>/blog/2020/python/python-standard-library-abc/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/2020/python/python-standard-library-abc/</guid>
      <description>0x00 为什么需要 abc 模块 abc 模块为调用者和具体实现类（而不是抽象类）之间提供更高级别的语义化约定。你使用类 A 之前，类 A 就给你保证它有 b 方法和 c 属性，不需要你在使用的时候通过 getattr 来判断，这个就是约定（contract）。
上面说的那句话是什么意思其实我也不是很懂，我理解它其实就类似于静态语言中的接口，子类必须实现抽象基类中的所有抽象方法和属性。而 abc 模块就帮你完成了这些事情。
详情请查看 PEP 3119
0x01 abc.ABCMeta 对象介绍  ABCMeta 是一个元类（metaclass），用来定义 Abstract Base Classes (ABCs)
ABCMeta 可以被继承，可以作为一个 Mixin Class。
可以注册不相关的具体类和 ABCs，作为虚拟类，他和他的子类会被认为是注册的 ABC 的子类（使用内置的 issubclass 函数来判断），但是注册的 ABC 不会出现在他们的 MRO（Method Resolution Order）中，注册 ABC 的方法也不能被调用。
通过 ABCMeta 元类创建的类具有以下方法：
 register(subclass)
 注册一个子类，作为这个 ABC 的虚拟子类 注意：虚拟子类与 C++ 中的虚拟子类概念不是一回事  from abc import ABCMeta class MyABC: __metaclass__ = ABCMeta MyABC.</description>
    </item>
    
  </channel>
</rss>