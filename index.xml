<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gra55&#39;s Blog</title>
    <link>/</link>
    <description>Recent content on Gra55&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Dec 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>HTTP 协议透彻解析</title>
      <link>/blog/2019/web/http-overview/</link>
      <pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/web/http-overview/</guid>
      <description>keywords: + http 协议是什么（历史、未来发展） + http 协议的传输过程 + http 协议包内容 + http 协议的问题
 0x00 HTTP 协议是什么  btw：什么是协议？ 协议不光在计算机中使用，我们平时生活中经常会用到协议。比如说两个网友奔现，双方都不认识，那就必须定义一个约定或者协议：男方来了必须穿黑色牛仔裤，手里拿一束花，女方必须穿白色上衣，背红色包包。这样，才能互相认识，否则就无法完成奔现。
 先参照上面的例子简单说下 HTTP 协议：女方就好比是 Client 端，男方就好比是 Server 端。Client 和 Server 进行通信的时候双方不认识，那就必须遵守某种协议才能进行交互。这个协议就是 HTTP 协议。
接下来用正式的、官方的解释说下 HTTP 协议：HTTP 协议是一种通过 Web 获取资源（HTML、CSS、文本等）的协议。它是数据交互的基础，是一种 C-S 结构的协议。
官方的解释很清楚，HTTP 协议的作用就是在网络上获取资源。
Key point： + HTTP 交互的是单独的 message，而不是数据流（stream of data） + HTTP 是应用层协议，通过 TCP 或者 TLS 加密的 TCP 连接发送数据 + HTTP 协议的高度可扩展性，使它能传输任何类型的文件（video、imag 等） + Client 与 Server 中间可以有多层代理 + HTTP 协议依靠 HTTP headers 可以自由的扩展功能 + HTTP 协议是无状态的（stateless，同一个连接先后发送的两个请求是没有联系的），但是是有会话状态的（not sessionless，通过 HTTP header 的可扩展性，HTTP cookie 支持有状态的会话）</description>
    </item>
    
    <item>
      <title>TED演讲：什么是区块链？</title>
      <link>/awesome/what-is-block-chain/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/awesome/what-is-block-chain/</guid>
      <description> 0x00 《什么是区块链？》  document.getElementById(&#34;video-bilibili&#34;).style.height=document.getElementById(&#34;video-bilibili&#34;).scrollWidth*0.5+&#34;px&#34;;  </description>
    </item>
    
    <item>
      <title>抛弃 Python2，从此使用 Python3</title>
      <link>/blog/2019/python/why-upgrade-python3/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/python/why-upgrade-python3/</guid>
      <description>为什么要使用 Python3？我 2 用的好好的。（py 版本演进过程；2018 年开发者问卷调查；）
Python 2 3 的特性对比
到底写 2 还是写 3，还是两个都写。（如果是自己的项目，只写 py3，如果是提供的第三方库，需要写 3 代码来兼容 2。为什么不是写 2 的代码兼容 3 呢？2 孔的插座好比 Python2，3 孔的好比 Python3，本来是 2 孔的充电器插 2 孔的电源，3 孔的插 3 孔的。现在假如 2 孔的插座快淘汰了，你是愿意给 3 孔的充电器安装一个 2 孔的转接头，让他可以用使用 2 孔的插座呢，还是另外一种做法）
如何逐步迁移到 Python 3（不迁移的话，你永远在使用 py2，因为你迈不出第一步）（需要注意很多老库不支持 py3）
迁移工具有哪些
如何部署 Python 2 和 Python3 的环境，并且还有虚拟环境
 0x00 为什么要升级到 Python3 Python2 + Python2 算是一种比较古老的语言 + 2010 年 7 月，发布 2.7.0 版本的时候，就宣布了以后不会再发布 Python 2.</description>
    </item>
    
    <item>
      <title>视频：林轩田机器学习基石</title>
      <link>/awesome/machine-learning-foundation/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/awesome/machine-learning-foundation/</guid>
      <description> 0x00 《机器学习基石》  document.getElementById(&#34;video-bilibili&#34;).style.height=document.getElementById(&#34;video-bilibili&#34;).scrollWidth*0.5+&#34;px&#34;;  </description>
    </item>
    
    <item>
      <title>Python 与 Golang 语法特性对比</title>
      <link>/blog/2019/go/go-compare-python/</link>
      <pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/go/go-compare-python/</guid>
      <description>0x00 缘起 之前整体把 golang 的语法过了一遍，花了大概几个小时。
然鹅，2 天没写 go 代码，语法就忘完了，还得回过头去查一次，真是浪费时间。
所以，我就想到了这个联想记忆，通过熟悉的东西，来记住陌生的东西。
0x01 语法特性对比  参考：go 语言之旅
     Python Go     包声明 文件名 文件内定义：package main   引入包 import json import &amp;ldquo;math/rand&amp;rdquo;   模块对象暴露 __all__ 包内对象首字母大写   函数 def 关键字 func 关键字   函数多指返回 return x, y return x, y（特例：func split(sum int) (x, y int) { x = sum * 4 / 9; y = sum - x; return }）   变量 动态类型 关键字 var，在变量名后声明（多个变量类型相同时，前边类型可以忽略）   变量初始化 直接赋值 如果提供初始值，则不需要指明类型   短变量声明 / :=（函数外必须使用 var 关键字）   基本类型 int、string、bool、list、dict、tuple bool、string、int[8, 16, 32, 64]、uint[8, 16, 32, 64]、uintptr、byte（uint8 的别名）、rune（int32 的别名；表示一个 Unicode 码点）、float32、float64、complex64、complex128   零值 / 没有赋初值的变量默认为零值（int 为 0；bool 为 false；字符串为 &amp;ldquo;；指针为 nil；切片为 nil，它的长度和容量为 0，且没有底层数组；映射为 nil，nil 映射既没有键，也不能添加键；）   类型转换 同 go 语言 T(v) 将值 v 转换为类型 T（不同类型直接赋值需要显式转换）   常量 与变量相同 关键字 const，不能使用 := 语法（常量不指明类型的话，会根据上下文自动识别其类型）   for for i in [1, 2, 3]: for i:=0; i&amp;lt;10; i++ {xxx}（初始化语句和后置语句是可选的）   while while True: for sum &amp;lt; 1000 {xxx}   死循环 while True: for {xxx}   if if i &amp;lt; 10: xxx else: xxx if v := math.</description>
    </item>
    
    <item>
      <title>Hugo 配置 staticman 静态评论平台</title>
      <link>/blog/2019/blog/hugo-plus-staticman/</link>
      <pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/blog/hugo-plus-staticman/</guid>
      <description>0x00 起因 我使用的 hugo 主题 hugo-future-imperfect，默认支持 disqus 和 staticman 的评论方式。
奈何有一些不可描述的原因，disqus 无法访问，遂转投 staticman 怀抱，这才开启了踩坑之路。
0x01 太年轻 准备按照 staticman 的 Getting started 一步一步执行。
可谓是出师不利，第一步就过不去：无法把 staticmanapp 账户添加到 Collaborators 中。

随后访问 https://api.staticman.net/v2/connect/LoveXiaoLiu/blog-comment 也是各种报错。

于是去 staticman 的 issue 区找找，果然很多人遇到了这个问题。
出现这个问题的原因是由于使用 staticman 的人太多了，导致部署的公共 staticman app 达到了 Github 的限制（Github 限制每个用户每小时只能调用 API 5K 次）。
 为什么会达到这个限制呢？  staticman 的工作方式是这样的，你将 staticman 添加到你的博客系统以后，需要将 staticmanapp 账户添加到你的 repo Collaborators 中。当有人在你的博客中提交评论，staticman 会将这些评论内容通过公开的 staticman app，以提交代码的方式提交到你的 repo 中。问题就出在这里，提交代码的账户就是 staticmanapp，随着 staticman 的用户越来越多，staticmanapp 肯定会超过这个限制的。 目前这个账户已经被注销。 针对这个问题，维护人员咨询了 GitHub 官方，官方回复让他创建一个 GitHub App 参考 issues 243   0x02 自己动手 本来想自己动手搭建一个 staticman app（参考这个教程）</description>
    </item>
    
    <item>
      <title>开发 Python 第三方包，上传到 PyPI</title>
      <link>/blog/2019/python/python-package-pypi/</link>
      <pubDate>Tue, 09 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/python/python-package-pypi/</guid>
      <description>0x00 初始化 skeleton 开源一个 Python 第三方包，需要配置很多额外的东西（pip 需要的 setup.cfg，CI/CD 需要的 .travis.yml 等），这些东西完全没必要自己来逐一创建。
所以我们需要一个脚手架来快速创建项目的 skeleton。这里我推荐使用 cookiecutter-X 系列工具。
我这里开发 pypi 包，使用 cookiecutter-pypackage 模板。
cookiecutter https://github.com/audreyr/cookiecutter-pypackage.git  0x01 生态配置 创建完项目 skeleton 以后，需要关联 Travis 账号、ReadTheDocs 账号等。步骤如下：
 将 repo 添加到 GitHub 中 将该 repo 添加到 Travis CI 中（需要注册 Travis 账号） 安装 dev requirement.txt 到虚拟开发环境中：pip install -r requirements_dev.txt 注册项目到 PyPI 中（需要注册 PyPI 账号）  生成 tar&amp;amp;wheel 包：python setup.py sdist bdist_wheel 上传包到 PyPI 中：python -m twine upload dist/*  将该 repo 添加到 ReadTheDocs 中  0x02 迭代开发  更新项目代码，开发新 features 使用 bumpversion 升级版本：bumpversion --current-version 0.</description>
    </item>
    
  </channel>
</rss>